# X86处理器寄存器笔记（一）

整理自CSDN 
原文：https://blog.csdn.net/wang010366/article/details/52015264 

## 寄存器基本概念

寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。其实寄存器就是一种常用的时序逻辑电路，但这种时序逻辑电路只包含存储电路。寄存器的存储电路是由锁存器或触发器构成的，因为一个锁存器或触发器能存储1位二进制数，所以由N个锁存器或触发器可以构成N位寄存器。寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。以Intel 80x86 CPU为例，80x86 CPU的寄存器组包括若干个8位、16位和32位寄存器，其中，32位寄存器是从80386 CPU开始才引入的。

## **寄存器分类**

### **1、数据寄存器**(通用寄存器)

数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。**RAX、RBX、RCX、RDX**和**EAX、EBX、ECX、EDX**以及**AX、BX、CX、DX**分别称为64位、32位、16位数据寄存器。

### 2、变址寄存器(Index Register)

变址寄存器主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。变址寄存器它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。

寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器。

### 3、指针寄存器(PointerRegister)

指针寄存器主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。

指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。
寄存器RBP、RSP和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器。

指令寄存器它们主要用于访问堆栈内的存储单元，并且规定：

（1）BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；

（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。

### 4、段寄存器

段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量值组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。

CS——代码段寄存器(CodeSegmentRegister)，其值为代码段的段值；

DS——数据段寄存器(DataSegmentRegister)，其值为数据段的段值；

ES——附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值；

SS——堆栈段寄存器(StackSegmentRegister)，其值为堆栈段的段值；

FS——附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值；

GS——附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值。

### 5、指令指针寄存器

指令指针寄存器是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。

RIP、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器。

### 6、标志寄存器

#### 一、运算结果标志位

##### （1） 进位标志CF(Carry Flag)
 进位标志的基本规则是若加法时结果最高位向前有进位或减法时最高位向前有借位，则CF=1，否则CF=0。

#####（2）奇偶标志PF(Parity Flag)

奇偶标志的基本规则是若结果最低字节中1的个数为偶数，则PF=1，否则PF=0。标志寄存器中除了有状态标志以外，还有3个控制标志，控制标志是由程序根据需要用指令来设置的，以控制某些指令的执行方式。

##### （3）辅助进位标志AF(Auxiliary Carry Flag)

 辅助进位标志也称为半进位标志，它的基本规则是若加法时结果低4位（半个字节）向前有进位或减法时结果低4位向前有借位，则AF=1，否则AF=0。该标志主要由CPU内部使用，用于BCD码调整指令。

#####（4）零标志ZF(Zero Flag)
零标志的基本规则是若运算结果为0，则ZF=1，否则ZF=0。

##### （5）符号标志SF(Sign Flag)
符号标志的基本规则是若运算结果为负数，则SF=1，否则SF=0。即SF取结果的最高位。

 ##### （6）溢出标志OF(Overflow Flag)
溢出标志的基本规则是溢出时置1，否则置0。即如果带符号数的运算结果超出了补码表示的范围，则OF=1，否则OF=0。

#### 二、状态控制标志位

状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。

##### （1）追踪标志TF(Trap Flag)
追踪标志用于控制CPU是否进入单步调试方式，当TF=1时，CPU以单步方式执行指令，即在每条指令执行结束后，产生中断1，以便对程序进行检查。特别需要说明的是，Intel 80x86 CPU没有提供直接修改该标志的指令。

#####（2）中断允许标志IF(Interrupt-enable Flag)
​    中断标志用于控制CPU是否响应外部可屏蔽中断请求，若IF=1，则允许中断，否则禁止中断。

##### （3） 方向标志DF(Direction Flag)
方向标志在串处理指令中控制信息的方向，若DF=0，则每次串操作后内存地址自动递增，否则自动递减。

#### 三、32位标志寄存器增加的标志位

##### （1）I/O特权标志IOPL(I/O Privilege Level)

I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。

##### （2）NT(Nested Task)

嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下：
    当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作；
    当NT=1，通过任务转换实现中断返回。

##### （3）重启动标志RF(Restart Flag)
重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1，中国自学编程网整理发布！

##### （4）虚拟8086方式标志VM(Virtual 8086 Mode)

 如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态。

AL与AH、BL与BH、CL与CH、DL与DH分别对应于AX、BX、CX和DX的低8位与高8位，L 即Low（低）之意，H即High（高）之意。AX、BX、CX、DX、SI、DI、BP和SP分别对应于EAX、EBX、ECX、EDX、ESI、 EDI、EBP和ESP的低16位，EAX、EBX、ECX、EDX、ESI、EDI、EBP和ESP都是32位的。EAX（含AX、AH和AL）、 EBX（含BX、BH和BL）、ECX（含CX、CH和CL）和EDX（含DX、DH和DL）统称为数据寄存器；ESI（含SI）和EDI（含DI）统称为变址寄存器； EBP（含BP）和ESP（含SP）统称为指针寄存器。

在对8/16位寄存器进行操作时，相应的16/32位寄存器的其他位不会受到影响。例如，EAX是一个32位通用寄存器，如果我们对AX进行了访问（即访问了EAX的低16位），那么EAX的高16位并不会改变。同理，我们可以使用AL来对AX的低8位进行访问，使用AH对AX的高8位进行访问，AL被修改时会影响AX，但不会影响AH，反之亦然。

## 16位寄存器

自Intel 8086和8088起，有14个16比特寄存器。其中四个（AX, BX, CX, DX）是通用目的（尽管每个寄存器都有附加目的；举个例子：只有CX可以被用来当作loop（循环）指令的计数器。）每个寄存器可以被当成两个分开的字节访问（因此BX的高比特可以被当成BH，低比特则可以当成BL）。除了这些寄存器，还有四个区块寄存器（CS、DS、SS、ES）。他们用来产生内存的绝对地址。还有两个指针寄存器（SP是指向堆栈的底部，BP可以用来指向堆栈或内存的其它地方）。两个指针寄存器（SI和DI）可以用来指向数组的内部。最后，有旗标寄存器（包含状态旗标比如进位、溢出、结果为零，等等）。以及IP是用来指向目前运行指令的地址。

8个16位通用寄存器，它们是AX、BX、CX、 DX、SI、DI、BP、SP。

4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。

| 指令                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| AH累加器(Accumulator)         | 可用于乘、除、输入/输出等操作(在乘除指令中指定用来存放操作数) |
| AL                            |                                                              |
| BH基地址寄存器(Base Register) | 在计算存储器地址时，可作为基址寄存器使用。                   |
| BL                            |                                                              |
| CH计数寄存器(Count Register)  | 在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数； |
| CL                            |                                                              |
| DH数据寄存器(DataRegister)    | 在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。 |
| DL                            |                                                              |

## 32位寄存器

自Intel 80386起，四个通用寄存器（EAX, EBX, ECX, EDX），它们较低的16位分别与原本16位的通用寄存器（AX, BX, CX, DX）重叠共用。指针寄存器（EIP, EBP, ESP, ESI, EDI）。区块寄存器除了原本的（CS、DS、SS、ES），另外新增（FS、GS），但是区块寄存器在32位模式下改做为内存区块的选择子寄存器。旗标寄存器被扩展为32位，较低的16位与原本在16位下的旗标寄存器重叠共用。

8个32位通用寄存器，它们是EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP。

| 指令                                   | 描述                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| eax                                    | EAX被称为32位累加器                                          |
| ecx（计数寄存器）                      | ECX中的C即Count（计数之意）。在许多指令中，ECX、CX、CL被用作计数器。 |
| edx（数据寄存器）                      | EDX中的D即Data（数据之意）。在进行乘法等运算时，常用EDX与EAX或DX与AX的组合来存放一个4字数或双字数。此外，DX也用来存放I/O端口地址。 |
| ebx（基址寄存器）                      | EBX中的B即Base（基址之意）。EBX与BX常用来表示内存地址，现在所使用的PC中地址都是较大的整数，一般不会是8位，所以BL就不常使用了。 |
| esp                                    | ESP或SP用来指示堆栈段中的栈顶地址。一般情况下不使用ESP或SP做算术运算。 |
| ebp                                    | EBP和BP常用来存放内存地址，它们在默认情况下指向堆栈段中的存储单元。 |
| esi                                    | ESI或SI在串指令中表示源数据串的地址。                        |
| edi                                    | EDI或DI在串指令中表示目的数据串的地址。                      |
| eip                                    | 指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。 |
| eflags（Flags Register）               | 标志寄存器也称为程序状态寄存器或状态寄存器。指令指针和标志寄存器不能用作指令的操作数，它们是由CPU直接操纵的。特别地，EIP和EFLAGS的低16位分别由IP和FLAGS标识。 |
| cs(Code Segment Register)代码段寄存器  | 其值为代码段的段值；                                         |
| ss(Stack Segment Register)堆栈段寄存器 | 其值为堆栈段的段值；                                         |
| ds(Data Segment Register)数据段寄存器  | 其值为数据段的段值；                                         |
| es(Extra Segment Register)附加段寄存器 | 其值为附加数据段的段值；                                     |
| fs(Extra Segment Register)附加段寄存器 | 其值为附加数据段的段值；                                     |
| gs(Extra Segment Register)附加段寄存器 | 其值为附加数据段的段值。                                     |

## 64位处理器

首先是MMX寄存器（MM0～MM7），它们分别与浮点运算器〈FP0～FP7〉相重叠，所以MMX与浮点运算不可同时使用，必须通过切换选择要使用哪一种。

之后在x86正式导入64位架构后，四个通用寄存器（RAX, RBX, RCX, RDX），它们较低的32位分别与原本32位的通用寄存器（EAX, EBX, ECX, EDX）重叠共用。指针寄存器（RIP, RBP, RSP, RSI, RDI）。以及增加八个通用寄存器（R8～R15）。

在2002年，由于32位特性的长度，x86的架构开始到达某些设计的极限。这个导致要处理大量的信息存储大于4GB会有困难，像是在数据库或是视频编辑上可以发现。

英特尔原本已经决定在64位的世代完全地舍弃x86兼容性，推出新的架构称为IA-64技术作为他的Itanium处理器产品线的基础。IA-64与x86的软件天生不兼容；它使用各种模拟形式来运行x86的软件，不过，以模拟方式来运行的效率十分低下，并且会影响其他程序的运行。

超微主动把32位x86（或称为IA-32）扩充为64位。它以一个称为AMD64的架构出现（在重命名前也称为x86-64），且以这个技术为基础的第一个产品是单核心的Opteron和Athlon 64处理器家族。由于AMD的64位处理器产品线首先进入市场，且微软也不愿意为英代尔和AMD开发两套不同的64位操作系统，英代尔也被迫采纳AMD64指令集且增加某些新的扩充到他们自己的产品，命名为EM64T架构（显然他们不想承认这些指令集是来自它的主要对手），EM64T后来被英代尔正式更名为Intel 64。

4个64位通用寄存器：RAX、RBX、RCX、RDX

4个64位指令寄存器：RSI、RDI、RBP、RSP

存器集成在CPU上，存取速度比存储器快好几个数量级，寄存器多了，GCC就可以更多的使用寄存器，替换之前的存储器堆栈使用，从而大大提升性能。
让寄存器为己所用，就得了解它们的用途，这些用途都涉及函数调用，X86-64有16个64位寄存器，分别是：%rax，%rbx，%rcx，%rdx，%esi，%edi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15。其中：

- %rax 作为函数返回值使用。

- %rsp 栈指针寄存器，指向栈顶

- %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。

- %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改

- %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值

C语言属于面向过程语言，他最大特点就是把一个程序分解成若干过程（函数），比如：入口函数是main，然后调用各个子函数。在对应机器语言中，GCC把过程转化成栈帧（frame），简单的说，每个栈帧对应一个过程。X86-32典型栈帧结构中，由%ebp指向栈帧开始，%esp指向栈顶。

| 指令                                   | 描述                     |
| -------------------------------------- | ------------------------ |
| rax                                    |                          |
| rbx                                    |                          |
| rcx                                    |                          |
| rdx                                    |                          |
| rsi                                    |                          |
| rdi                                    |                          |
| rbp                                    |                          |
| rsp                                    |                          |
| r8                                     |                          |
| r9                                     |                          |
| r10                                    |                          |
| r11                                    |                          |
| r12                                    |                          |
| r13                                    |                          |
| r14                                    |                          |
| r15                                    |                          |
| r16                                    |                          |
| rip                                    |                          |
| eflags                                 |                          |
| cs(Code Segment Register)代码段寄存器  | 其值为代码段的段值；     |
| ss(Stack Segment Register)堆栈段寄存器 | 其值为堆栈段的段值；     |
| ds(Data Segment Register)数据段寄存器  | 其值为数据段的段值；     |
| es(Extra Segment Register)附加段寄存器 | 其值为附加数据段的段值； |
| fs(Extra Segment Register)附加段寄存器 | 其值为附加数据段的段值； |
| gs(Extra Segment Register)附加段寄存器 | 其值为附加数据段的段值;  |

## 多媒体指令集

1. 精简指令集（RISC）:
- PA-RISC 多媒体加速扩展指令集 (MAX)
- SPARC    可视化指令集 (VIS)
- MIPS       MDMX、MIPS-3D
- Alpha      动态视频指令集 (MVI)
- POWER   AltiVec
- ARM       NEON
2. 复杂指令集（CISC）:
  x86/x86-64
  MMX · 3DNow! · 流式单指令流多数据流功能扩展指令集 (SSE) · SSE2 · SSE3 · 扩展SSE3 (SSSE3) · SSE4 · SSE4a · SSE5 → XOP、F16C/CVT16、FMA(包括FMA4、FMA3) · 高级加密标准指令集 (AES) · 高级矢量扩展指令集 (AVX、AVX1.1、AVX2、AVX-512) · 位操作指令集 (ABM、BMI1、BMI2、TBM)

---------------------
